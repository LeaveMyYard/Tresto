'''
This file contains a utility class to work with python file tresto metadata.
Each test file should have a header that contains following docstring:

"""Generated by Tresto v{version}

Test name: {test_name}
Test description: {test_description}
Created Date: {created_date}

"""

This is used to automatically save the AI information about the test.

'''

import re
import textwrap
from datetime import datetime
from pathlib import Path
from typing import Self

from pydantic import BaseModel, Field

from tresto import __version__


class TrestoFileHeaderCorrupted(ValueError):
    """Raised when the Tresto file header format is invalid or missing."""


class FileHeader(BaseModel):
    test_name: str
    test_description: str
    created_date: str = Field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d"))
    project_inspection_report: str | None = None
    content: str

    def write_to_file(self, file_path: Path) -> None:
        """Write content to file with Tresto header, replacing any existing docstring."""
        # Generate the new header docstring
        header_docstring = self.to_docstring()
        
        # Remove existing module docstring if present
        content_without_docstring = self._remove_module_docstring(self.content)
        
        # Add our header docstring at the beginning
        final_content = f'"""{header_docstring}"""\n\n{content_without_docstring}'
        
        # Write to file
        file_path.write_text(final_content)

    @classmethod
    def read_from_file(cls, file_path: Path) -> Self:
        """Read Tresto header from file and parse it into FileHeader instance."""
        if not file_path.exists():
            raise TrestoFileHeaderCorrupted(f"File does not exist: {file_path}")
        
        file_content = file_path.read_text()
        
        # Extract the first docstring (module docstring)
        docstring = cls._extract_module_docstring(file_content)
        if not docstring:
            raise TrestoFileHeaderCorrupted("No module docstring found")
        
        # Parse the docstring to extract header information
        header = cls._parse_header_docstring(docstring)
        
        # Add the content without the header docstring
        content_without_docstring = cls._remove_module_docstring(file_content)
        header.content = content_without_docstring
        
        return header

    def to_docstring(self) -> str:
        """Convert header to docstring format."""
        base_docstring = textwrap.dedent(
            f"""\
            Generated by Tresto v{__version__}

            Test name: {self.test_name}
            Test description: {self.test_description}
            Created Date: {self.created_date}"""
        ).strip()
        
        # Add project inspection report if present
        if self.project_inspection_report:
            return f"{base_docstring}\n\n{self.project_inspection_report}"
        
        return base_docstring

    @staticmethod
    def _remove_module_docstring(content: str) -> str:
        """Remove the first docstring (module docstring) from Python code."""
        # Pattern to match module docstring (first string literal in the file)
        # Matches triple quotes (both """ and ''') with content
        pattern = r'^\s*(?:"""[\s\S]*?"""|\'\'\'[\s\S]*?\'\'\')\s*\n?'
        
        # Remove the first docstring if it exists
        return re.sub(pattern, '', content, count=1).lstrip()

    @staticmethod
    def _extract_module_docstring(content: str) -> str | None:
        """Extract the first docstring (module docstring) from Python code."""
        # Pattern to match module docstring
        triple_quote_pattern = r'^\s*(""")([\s\S]*?)\1'
        single_quote_pattern = r"^\s*(''')([\s\S]*?)\1"
        
        # Try triple double quotes first
        match = re.match(triple_quote_pattern, content)
        if match:
            return match.group(2)
        
        # Try triple single quotes
        match = re.match(single_quote_pattern, content)
        if match:
            return match.group(2)
        
        return None

    @classmethod
    def _parse_header_docstring(cls, docstring: str) -> Self:
        """Parse Tresto header docstring and extract metadata."""
        # Expected format:
        # Generated by Tresto v{version}
        # 
        # Test name: {test_name}
        # Test description: {test_description}
        # Created Date: {created_date}
        #
        # {project_inspection_report} (optional, after two empty lines)
        
        docstring_content = docstring.strip()
        
        # Find the end of the main header by looking for the Created Date line
        lines = docstring_content.split('\n')
        main_header_lines = []
        project_report_lines = []
        
        # Track if we've passed the main header
        found_created_date = False
        header_complete = False
        
        for line in lines:
            if not header_complete:
                main_header_lines.append(line)
                if line.strip().startswith("Created Date:"):
                    found_created_date = True
                elif found_created_date and line.strip() == "":
                    # First empty line after Created Date - end of main header
                    header_complete = True
            else:
                # Everything after the main header is project report
                project_report_lines.append(line)
        
        # Reconstruct main header and project report
        main_header = '\n'.join(main_header_lines).strip()
        project_inspection_report = '\n'.join(project_report_lines).strip() if project_report_lines else None
        
        # Remove empty strings
        if project_inspection_report == "":
            project_inspection_report = None
        
        # Parse the main header
        header_lines = [line.strip() for line in main_header.split('\n')]
        
        # Check first line format
        if not header_lines or not header_lines[0].startswith("Generated by Tresto v"):
            raise TrestoFileHeaderCorrupted("Invalid header format: missing 'Generated by Tresto' line")
        
        # Extract metadata fields
        test_name = None
        test_description = None
        created_date = None
        
        for line in header_lines:
            if line.startswith("Test name:"):
                test_name = line[len("Test name:"):].strip()
            elif line.startswith("Test description:"):
                test_description = line[len("Test description:"):].strip()
            elif line.startswith("Created Date:"):
                created_date = line[len("Created Date:"):].strip()
        
        # Validate all required fields are present
        if not test_name:
            raise TrestoFileHeaderCorrupted("Missing 'Test name' field in header")
        if not test_description:
            raise TrestoFileHeaderCorrupted("Missing 'Test description' field in header")
        if not created_date:
            raise TrestoFileHeaderCorrupted("Missing 'Created Date' field in header")
        
        return cls(
            test_name=test_name,
            test_description=test_description,
            created_date=created_date,
            project_inspection_report=project_inspection_report,
            content=""  # Will be set by read_from_file
        )